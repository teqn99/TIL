# 210813 TIL

알고리즘들에 대해 공부했다.

브루트 포스는 많이 써봐왔지만 나머지는 아직 조금 낯설다. 특히 KMP 알고리즘은 잘 쓰이지 않더라도 확실히 알아두는 것이 좋을 것 같다.



### TIP

**sys.getsizeof()**

- 객체의 사이즈(크기)를 알아보는 함수



### 브루트 포스 알고리즘

>  (고지식한 패턴 검색 알고리즘)

본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식으로 동작

- 시간복잡도
  - 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이 된다.



### KMP 알고리즘

불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행

- 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화한다.
  - next[M] : 불일치가 발생했을 경우 이동할 다음 위치
- 시간 복잡도
  - O(M + N)

```python
cnt = 0  # 일치한 개수
next = [0]*m  # 
i = 1
while i < m:
    if p[i] == p[m]:
        cnt += 1
        next[i] = cnt
        i += 1
    else:
        if cnt != 0:
            cnt = next[cnt-1]
        else:
        	next[i] = 0
        	i += 1
```



### 보이어-무어 알고리즘

- 오른쪽에서 왼쪽으로 비교
- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
- 보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치라고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이 만큼이 된다.



### 문자열 매칭 알고리즘 비교

> 찾으려는 문자열의 길이: m, 총 문자열 길이: n 

- 브루트 포스

  - O(mn)

- 카프-라빈 알고리즘

  - O(n)

- KMP 알고리즘

  - O(n)

- 보이어-무어 알고리즘

  > 보이어-무어 알고리즘은 텍스트 문자를 다 보지 않아도 된다.
  >
  > 발상의 전환: 패턴의 오른쪽부터 비교한다.

  - 앞의 두 매칭 알고리즘들의 공통점 텍스트 문자열의 문자를 적어도 한번씩 훑는다는 것. 최선의 경우에도 O(n)
  - 최악의 경우: O(mn)
  - 일반적으로 O(n)보다 시간이 덜 든다.





