# 210823 TIL

점점 알고리즘 단계를 높이고 있다.

백트래킹은 말만 들어서는 DFS와 비슷한 줄 알았는데, 조금 더 빠를 수 있다는 것을 알게 되었다.

시간복잡도도 어느정도는 외우거나 이해해야겠다는 생각이 들었다.



### 백트래킹

- 백트래킹 기법은 해를 찾는 도중에 막히면 되돌아가서 다시 해를 찾아 가는 기법이다.
- 백트래킹 기법은 최적화문제와 결정 문제를 해결할 수 있다.
- 결정 문제: 문제의 조건을 만족하는 해가 존재하는지의 여부를 'yes' 또는 'no'가 답하는 문제
  - 미로 찾기
  - n-Queen 문제
  - Map Coloring
  - 부분 집합의 합 문제 등



### 백트래킹과 깊이우선탐색과의 차이

- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임. (Prunning 가지치기)
- 깊이우선탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단.
- 깊이우선탐색을 가하기에는 경우의 수가 너무나도 많다. 즉, N! 가지의 경우의 수를 가진 문제에 대해 깊이우선탐색을 가하면 문제를 처리하기 불가능해진다.
- 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만, 이 역시 최악의 경우에는 여전히 지수함수시간(Exponential Time)을 요하므로 처리가 불가능해진다.



### 백트래킹 기법

- 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 감
- 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면, 그 노드는 유망하지 않다고 하며 반대로 해답의 가능성이 있으면 유망하다고 한다.
- 가지치기 (Prunning): 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않는다.



> 백트래킹을 이용한 알고리즘은 다음과 같은 절차로 진행

1. 상태 공간 트리의 깊이 우선 탐색을 실시
2. 각 노드가 유망한지를 점검
3. 만일 그 노드가 유망하지 않다면, 그 노드의 부모 노드로 돌아가서 검색을 계속한다.



### 부분 집합 구하기

- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 powerset이라고 하며 구하고자하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 개수는 2n이 나온다.
- 백트래킹 기법으로 powerset을 구해보자.
  - 일반적인 백트래킹 접근 방법을 이용한다.
  - n개의 원소가 들어있는 집합의 2n개의 부분집합을 만들 때는, true 또는 false값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법을 이용
  - 여기서 배열의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값이다.

> 부분집합의 합

```python
def f(i, N, K):  # 합이 K인 부분집합을 출력
    global cnt1
    cnt1 += 1
    if i == N:  # 부분집합 생성완료
        s = 0
        for j in range(N):
            if bit[j] == 1:
                s += A[j]
        if s == K:  # 합이 찾는 값이면
            for j in range(N):
                if bit[j] == 1:
                    print(A[j], end=' ')  # 부분 집합 출력
        	print()
    else:  
        bit[i] = 1
        f(i+1, N, K)
        bit[i] = 0
        f(i+1, N, K)
        
        
def f2(i, N, K, S):  # 부분집합의 합이 K이면서, S를 통해 재귀 반복 횟수 줄이기
    global cnt2
    cnt2 += 1
    if S == K:
        print(bit, end=' ')
        for j in range(N):
            if bit[j] == 1:
                print(A[j], end=' ')  # 부분 집합 출력
        print()
    elif i == N:
        return
    elif S > K:
        return
    else:
        bit[i] = 1
        f2(i+1, N, K, S+A[i])
        bit[i] = 0
        f2(i+1, N, K, S)
        
        
def f3(i, N, K, S, RS):  # 부분집합의 합이 K이면서, S, RS를 통해 재귀 반복 횟수 줄이기
    global cnt3
    cnt3 += 1
    if S == K:
        print(bit, end=' ')
        for j in range(N):
            if bit[j] == 1:
                print(A[j], end=' ')  # 부분 집합 출력
        print()
    elif i == N:
        return
    elif S > K:
        return
    elif S + RS < K:
        return
    else:
        bit[i] = 1
        f3(i+1, N, K, S+A[i], RS-A[i])
        bit[i] = 0
        f3(i+1, N, K, S, RS-A[i])
        
        
A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
bit = [0]*10

cnt1 = 0
f(0, 10, 10)
print(cnt1)

cnt2 = 0
f2(0, 10, 10, 0)
print(cnt2)

cnt3 = 0
f3(0, 10, 10, 0, sum(A))
print(cnt3)
```

-> 탐색 과정을 줄이기 위해 중간에 검사하는 부분을 추가하는 것도 일종의 백트래킹이라 할 수 있다.

> 순열

```python
def f(i, N):  # P[i]의 값을 결정
    if i == N:  # 순열 완성
        print(P)
    else:  # i번 원소 값 결정
        # P[i] <-> P[j]: 자리 교환
        for j in range(i, N):  # 자신부터 오른쪽 원소와 교환
            P[i], P[j] = P[j], P[i]  # swap
            f(i+1, N)
            P[i], P[j] = P[j], P[i]  # 원상복구
        
        
P = [1, 2, 3]
f(0, 3)
```

> 부분 순열 구하기

```python
def f(i, N, r):
    if i == r:  # 순열 완성
        print(P[0:r])
    else:  # i번 원소 값 결정
        for j in range(i, N):  # 자신부터 오른쪽 원소와 교환
            P[i], P[j] = P[j], P[i]
            f(i+1, N, r)
            P[i], P[j] = P[j], P[i]
            
        
P = [1, 2, 3, 4, 5]
f(0, len(P), 3)
```





### 분할 정복 알고리즘

설계 전략

- 분할(Divide): 해결할 문제를 여러 개의 작은 부분으로 나눈다.
- 정복 (Conquer): 나눈 작은 문제를 각각 해결한다.
- 통합 (Combine): (필요하다면) 해결된 해답을 모은다.

시간복잡도

- O(logN)



